---
title: 现代图片性能优化
author: Missy
date: '2024-9-04'
---

# 图片类型

| 图片类型     | 透明通道 | 动画   | 编解码性能     | 压缩算法          | 颜色支持           | 内存占用 | 兼容性                               |
| ------------ | -------- | ------ | -------------- | ----------------- | ------------------ | -------- | ------------------------------------ |
| GIF          | 支持     | 支持   | 较高           | 无损压缩          | 索引色（256）      | 基本一致 | ALL                                  |
| PNG-8/PNG-24 | 支持     | 不支持 | 较高           | 无损压缩          | 索引色(256)\直接色 | 基本一致 | ALL                                  |
| JPEG         | 不支持   | 不支持 | 较高           | 有损压缩          | 直接色             | 基本一致 | ALL                                  |
| WebP（现代） | 支持     | 支持   | 编解码性能差   | 有损压缩\无损压缩 | 直接色             | 基本一致 | 高版本 Chrome\Opera\Android          |
| JPEG XL      | 支持     | 支持   | 渐进式解码     | 有损压缩\无损压缩 | 直接色             | 基本一致 | 部分高版本 Chrome\Opera\Firefox\Edge |
| AVIF         | 支持     | 支持   | 编解码性能一般 | 有损压缩\无损压缩 | 直接色             | 基本一致 | 高版本 Chrome\Opera\Android\Edge     |

## 参数含义:

* Alpha 通道：图片是否支持透明的特性(0代表透明，1代表不透明)
* 动画：是否支持多帧率动态图片
* 编解码性能：图像的解码与编码
* 压缩算法：图片格式是否支持压缩
* 颜色支持：分为索引色和直接色
* 内存占用：图片对内存资源的占用
* 兼容性：影响图片格式能否大规模推广的核心要素

## Picture元素使用

为渐进式增强，替代传统图片格式，借助使用`<Pictrue>`元素来解决浏览器不兼容的问题：使用如下；

```html
<picture>
  <!-- 可能是一些对兼容性有要求的，但是性能表现更好的现代图片格式-->
  <source src="image.avif" type="image/avif">
  <source src="image.jxl" type="image/jxl">
  <source src="image.webp" type="image/webp">

   <!-- 最终的兜底方案-->
  <img src="image.jpg" type="image/jpeg">
</picture> 

```

# 适配不同的屏幕尺寸和DPR

预备知识：1. 设备独立像素 2. 物理像素 3. 屏幕的DPR

* 设备独立像素 = CSS像素 = 逻辑像素（固定不变）

* 设备像素 = 分辨率 = 物理像素  （支持调整）

* DPR (视网膜屏幕)= 物理像素 / 设备独立像素 （与分辨率成正比关系，用多少个像素点去当一个css像素使用）

  ```
  750 / 375 = 2  这里指的是iPhone7 的 dpr 为 2。也就是我们常说的视网膜屏幕
  释：在视网膜屏幕中，以dpr = 2为例，把（2*2）4个像素当一个像素使用，这样让屏幕看起来更精致，但是元素的大小本身却不会变；
  ```

在设备独立像素不变的情况下，如果设置的分辨率不同，DPR不同;（分辨率越高，DPR值越大，显示的更清晰；

`DPR与图片适配有什么关系呢？` 在高DPR设备下（高分辨率）下，只提供只有CSS像素大小的图片，是非常模糊的；

为了在不同的DPR屏幕下，让图片看起来都不失真；

假设：移动端需要一张css像素为`300 * 200 `的图像，考虑到现在已经有了dpr = 3 的设备，那么要保证图片在dpr = 3的设备下也能高清展示，我们最大可能需要一张`900  * 600`的原图；

## 为了不同的DPR屏幕，提供恰当的图片

* 方案一：无脑多倍图造成大量带宽的浪费，现代浏览器提供了更好的方式，让我们能够根据设备dpr的不同，提供不同的尺寸的图片；

* 方案二：媒体查询：通过知道当前设备不同的dpr值，使用对应的图片；

  ```css
  #id { 
      background: url(xxx@2x.png) 
  }
  @media (device-pixel-ratio: 2) {
      #id { 
          background: url(xxx@2x.png) 
      }
  }
  @media (device-pixel-ratio: 3) {
      #id { 
          background: url(xxx@3x.png) 
      }
  }
  
  ```

* 方案三：CSS 配合 image-set 语法;

  ```css
  .img {
      /* 不支持 image-set 的浏览器*/
      background-image: url('../photo@2x.png');
  
      /* 支持 image-set 的浏览器*/
      background-image: image-set(
          url('./photo@2x.png') 2x,
          url('./photo@3x.png') 3x
      );
  }
  
  ```

  ... 

# 图片宽高比、裁剪、缩放

存在问题：
——> 出现非正常大小的图片，不加保护的布局就会出现问题； 
——> 建议同时写上宽高，避免因为图片尺寸错误带来的布局问题；（给img 设置宽高，可以在图片未加载之前提前占位，避免图片从未加载状态到渲染完成状态宽高变化引起的重排问题） 
——> 宽高写死不合适，布局是响应式动态变化的，使用aspect-ratio设定宽高比 
——> 

* aspect-ratio: 避免布局偏移；设置宽高比，无论父元素宽度如何变化，让图片大小自动缩放；

  ```css
  ul li img {
      width: 100%;
      aspect-ratio: 3 / 2;
  }
  ```
* object-fit：避免图片拉伸；适应父容器的宽高；
* object-position：控制图片在其内容框中的位置
  ```css
  ul li img {
    width: 150px;
    aspect-ratio: 3 / 2;
    object-fit: cover;
    object-position: 50% 100%;
  }
  ```
* image-rendering：图像缩放时，减少图片失真带来的信息损耗；


# 参考文档
[现代图片性能优化及体验优化指南](https://juejin.cn/post/7216518492613296188?searchId=202409041136327085DF3D482A32E74AD4#heading-12)